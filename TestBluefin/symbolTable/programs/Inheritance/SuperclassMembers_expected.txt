declare - Base - c_struct - t_Base
setCurrentScope - Level 1
resolve - int - c_builtinType - t_int
declare - a - c_var - t_int
resolve - bool - c_builtinType - t_bool
declare - b - c_var - t_bool
resolve - void - c_builtinType - t_void
declare - f - c_function - t_void
enterScope - Level 2
exitScope - Level 2
exitScope - Level 1
declare - Der - c_struct - t_Der
setCurrentScope - Level 1
resolve - bool - c_builtinType - t_bool
declare - a - c_var - t_bool
resolve - Base - c_builtinType - t_Base
declare - b - c_var - t_Base
resolve - float - c_builtinType - t_float
declare - f - c_function - t_float
enterScope - Level 2
exitScope - Level 2
exitScope - Level 1
resolve - int - c_builtinType - t_int
declare - main - c_function - t_int
enterScope - Level 1
resolve - Der - c_struct - t_Der
declare - der - c_var - t_Der
resolve - a - c_var - t_bool


/*
If derived class has member fields with same name as base class, we can still access the superclass' fields and methods with the 'super' keyword. 
*/

struct Base {
	int a;
	bool b;
	
	void f() {}
};

struct Der extends Base {
	bool a;
	Base b;
	
	void f(int x) {
		a = true;
		super.a = 5;
		super.b = true;
		super.f();
	}
};

int main() {
	Der der;
	der.f(5);
	der.super.f();
	der.super.f(5);
	
	der.super.a = 1;
}